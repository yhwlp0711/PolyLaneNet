Git hash: 6b135a90326a145c74f2d1ca270bfcc56c9dfd41

*************
Git diff:
*************
diff --git a/README.md b/README.md
index b4af404..4a1a190 100644
--- a/README.md
+++ b/README.md
@@ -122,7 +122,7 @@ This script's options are:
 #### Testing
 After training, run the `test.py` script to get the metrics:
 ```bash
-python test.py --exp_name tusimple --cfg config.yaml --epoch 2695
+python beziertest.py --exp_name tusimple --cfg config.yaml --epoch 2695
 ```
 This script's options are:
 ```
@@ -158,7 +158,7 @@ If you just want to reproduce the exact reported metrics by testing the model, y
 Then, run:
 
 ```bash
-python test.py --exp_name $exp_name --cfg $exps_dir/$exp_name/config.yaml --epoch 2695
+python beziertest.py --exp_name $exp_name --cfg $exps_dir/$exp_name/config.yaml --epoch 2695
 ```
 Replacing `$exp_name` with the name of the directory you downloaded (the name of the experiment) and `$exps_dir` with the `exps_dir` value you defined inside the `config.yaml` file. The script will look for a directory named `$exps_dir/$exp_name/models` to load the model.
 
diff --git a/bezier/bezier.py b/bezier/bezier.py
index 0780b46..a91e8c7 100644
--- a/bezier/bezier.py
+++ b/bezier/bezier.py
@@ -4,7 +4,7 @@ import numpy as np
 
 
 def distance(p1, p2):
-    return math.sqrt(((p1-p2)**2).sum())
+    return math.sqrt(((p1 - p2) ** 2).sum())
 
 
 class bezier:
@@ -16,7 +16,7 @@ class bezier:
                   self.points是曲线上的点，其个数要不小于顶点数）
             n: 阶数, 这里为2或3(这里我只支持二阶和三阶，其实也可以扩展为更一般化，添加不同的T即可)
         """
-        assert len(points) >= n+1
+        assert len(points) >= n + 1
         self.n = n
         if n == 2:
             self.T = bezier.T_2
@@ -26,37 +26,37 @@ class bezier:
             self.t = bezier.t_3
         self.__points = points
         self.solve()
-            
+
     def __call__(self, t):
         t = self.t(t).reshape(1, -1)
-        return bezier.calc(self.P,t)
-    
+        return bezier.calc(self.P, t)
+
     @property
     def points(self):
         return self.__points
+
     @points.setter
     def points(self, points):
         self.__points = points
         self.solve()
-    
+
     def solve(self):
         ts = [0]
         ts += [distance(p1, p2) for p1, p2 in zip(self.__points[0:-1], self.__points[1:])]
         ts_sum = sum(ts)
-        
+
         for i in range(1, len(ts)):
-            ts[i] = ts[i-1] + ts[i]
-        ts = [t/ts_sum for t in ts]
+            ts[i] = ts[i - 1] + ts[i]
+        ts = [t / ts_sum for t in ts]
         T = self.T(ts)
-        assert T.shape[0] >= self.n+1
-        if T.shape[0] == self.n+1:
+        assert T.shape[0] >= self.n + 1
+        if T.shape[0] == self.n + 1:
             self.P = np.dot(np.linalg.inv(T), self.__points)
         else:
             TtT_inv = np.linalg.inv(np.dot(T.T, T))
             TtB = np.dot(T.T, self.__points)
             self.P = np.dot(TtT_inv, TtB)
-            
-    
+
     @staticmethod
     def calc(P, t):
         """
@@ -65,19 +65,21 @@ class bezier:
         """
         assert P.shape[0] == t.shape[1]
         return np.dot(t, P)
-    
+
     @staticmethod
     def t_2(t):
-        return np.asarray([(1-t)**2, 2*t*(1-t), t**2])
+        return np.asarray([(1 - t) ** 2, 2 * t * (1 - t), t ** 2])
+
     @staticmethod
     def T_2(ts):
         assert len(ts) >= 3
         T = [bezier.t_2(t) for t in ts]
         return np.asarray(T)
-    
+
     @staticmethod
     def t_3(t):
-        return np.asarray([(1-t)**3, 3*t*(1-t)**2, 3*t**2*(1-t), t**3])
+        return np.asarray([(1 - t) ** 3, 3 * t * (1 - t) ** 2, 3 * t ** 2 * (1 - t), t ** 3])
+
     @staticmethod
     def T_3(ts):
         assert len(ts) >= 4
diff --git a/lib/bezier.py b/lib/bezier.py
index e69de29..c2e918d 100644
--- a/lib/bezier.py
+++ b/lib/bezier.py
@@ -0,0 +1,71 @@
+import numpy as np
+import torch
+
+
+def bezier_curve(t, P):
+    """
+    计算贝塞尔曲线在参数t下的点
+    """
+    return (1 - t) ** 3 * P[0] + 3 * (1 - t) ** 2 * t * P[1] + 3 * (1 - t) * t ** 2 * P[2] + t ** 3 * P[3]
+
+
+def bezier_curve_derivative(t, P):
+    """
+    贝塞尔曲线的导数
+    """
+    return -3 * (1 - t) ** 2 * P[0] + 3 * (1 - t) ** 2 * P[1] - 6 * t * (1 - t) * P[1] + 6 * t * (1 - t) * P[
+        2] - 3 * t ** 2 * P[2] + 3 * t ** 2 * P[3]
+
+
+def find_x_from_y(y_target, P, epsilon=1e-6, max_iterations=100):
+    """
+    在给定的y值下找到对应的x值
+    """
+    t = 0.5  # 初始值可以是0.5
+    for _ in range(max_iterations):
+        y = bezier_curve(t, P)[1]
+        if abs(y - y_target) < epsilon:
+            break
+        t -= (y - y_target) / bezier_curve_derivative(t, P)[1]
+
+    # 使用找到的t值计算对应的x值
+    x = bezier_curve(t, P)[0]
+
+    return x
+
+def cal_list(y_target, x_target, valid_xs, pred_polys):
+    x_target.t()
+    lanenums, pointnums = y_target.shape
+    start_idx = -1
+    end_idx = -1
+    res = []
+    device = y_target.device
+    # for i in range(lanenums):
+    #     print(x_target[i])
+    #     print(valid_xs[i])
+    for i in range(lanenums):
+        for j in range(pointnums - 1, -1, -1):
+            if valid_xs[i, j]:
+                end_idx = j
+                break
+        for j in range(pointnums):
+            if  valid_xs[i,j]:
+                start_idx = j
+                break
+        p0 = torch.cat([x_target[i, start_idx].expand(1), y_target[i, start_idx].expand(1)])
+        p1 = torch.cat([pred_polys[i, 0].expand(1),pred_polys[i, 1].expand(1)])
+        p2 = torch.cat([pred_polys[i, 2].expand(1), pred_polys[i, 3].expand(1)])
+        p3 = torch.cat([x_target[i, end_idx].expand(1),y_target[i,end_idx].expand(1)])
+        # tempx = [find_x_from_y(y,[p0,p1,p2,p3]) for y in y_target[i]]
+        tempx = torch.Tensor([find_x_from_y(y,[p0,p1,p2,p3]) for y in y_target[i]]).to(device)
+        # tempx = tempx.to(device)
+        res.append(tempx)
+    res = torch.stack(res, 0)
+    return res
+# # 示例
+# P = np.array([[2, 6.34], [5.87, 7.46], [7.75, 4], [3.71, 0.52]])  # 四个控制点
+# y_targets = [2, 3, 4.5]  # 给定的y值列表
+#
+# x_values = [find_x_from_y(y, P) for y in y_targets]
+#
+# print("对应的x值:", x_values)
diff --git a/lib/models.py b/lib/models.py
index d76f0ca..c7e523e 100644
--- a/lib/models.py
+++ b/lib/models.py
@@ -3,6 +3,8 @@ import torch.nn as nn
 from torchvision.models import resnet34, resnet50, resnet101
 from efficientnet_pytorch import EfficientNet
 
+from .bezier import cal_list
+
 
 class OutputLayer(nn.Module):
     def __init__(self, fc, num_extra):
@@ -110,8 +112,8 @@ class PolyRegression(nn.Module):
         return outputs, extra_outputs
 
     def loss(self,
-             outputs,
-             target,
+             outputs, # batchsize * 35 (lanenums=5 * (1 + 2 + 4))
+             target, # batchsize * lanenums=5 * 115 每条车道115个点？
              conf_weight=1,
              lower_weight=1,
              upper_weight=1,
@@ -136,10 +138,12 @@ class PolyRegression(nn.Module):
         # 小于置 0 大于不变
         threshold = nn.Threshold(threshold**2, 0.)
         # 获取预测结果
-        pred = pred.reshape(-1, target.shape[1], 1 + 2 + 4)
+        pred = pred.reshape(-1, target.shape[1], 1 + 2 + 4) # batchsize * lanenums=5 * 7
         # 提取各结果
+        # batchsize * lanenums=5 再 reshape (batchsize * lanenums=5) * 1 每条车道线一个数据
         target_categories, pred_confs = target[:, :, 0].reshape((-1, 1)), s(pred[:, :, 0]).reshape((-1, 1))
         target_uppers, pred_uppers = target[:, :, 2].reshape((-1, 1)), pred[:, :, 2].reshape((-1, 1))
+        # 前者为 (batchsize * lanenums) * pointnums 后者为 (batchsize * lanenums) * 7
         target_points, pred_polys = target[:, :, 3:].reshape((-1, target.shape[2] - 3)), pred[:, :, 3:].reshape(-1, 4)
         target_lowers, pred_lowers = target[:, :, 1], pred[:, :, 1]
 
@@ -162,11 +166,11 @@ class PolyRegression(nn.Module):
 
         # 每个元素等于对应车道的可信度
         target_confs = (target_categories > 0).float()
-        # 筛选出具有可信度车道的索引
+        # 筛选出具有可信度车道的索引 即有效车道
         valid_lanes_idx = target_confs == 1
         # 二维->一维
         valid_lanes_idx_flat = valid_lanes_idx.reshape(-1)
-        # 上界损失、下界损失
+        # 上界损失、下界损失 标量
         lower_loss = mse(target_lowers[valid_lanes_idx], pred_lowers[valid_lanes_idx])
         upper_loss = mse(target_uppers[valid_lanes_idx], pred_uppers[valid_lanes_idx])
 
@@ -185,17 +189,26 @@ class PolyRegression(nn.Module):
 
         # poly loss calc
         # 提取 x
-        # valid_lanes_idx_flat 为 bool 掩码
+        # valid_lanes_idx_flat 为 bool 掩码  有效车道的个数(从 batchsize * lanenums 中筛选) * 有效点的数量
         target_xs = target_points[valid_lanes_idx_flat, :target_points.shape[1] // 2]
         # 提取 y 再转置
-        ys = target_points[valid_lanes_idx_flat, target_points.shape[1] // 2:].t()
-        # bool 掩码
+        # 多项式 ys
+        # ys = target_points[valid_lanes_idx_flat, target_points.shape[1] // 2:].t()
+        # 贝塞尔 ys
+        ys = target_points[valid_lanes_idx_flat, target_points.shape[1] // 2:]
+        # bool 掩码  再计算 x > 0 的掩码
         valid_xs = target_xs >= 0
-        # 筛选有效值
+        # 筛选有效值 pred_polys (batchsize * lanenums) * 4
         pred_polys = pred_polys[valid_lanes_idx_flat]
-        # 根据 ys 和多项式系数计算 xs 并转置
-        pred_xs = pred_polys[:, 0] * ys**3 + pred_polys[:, 1] * ys**2 + pred_polys[:, 2] * ys + pred_polys[:, 3]
-        pred_xs.t_()
+
+
+        # 根据 ys 和多项式系数计算 xs 并转置 计算预测 x
+        # 改曲线改这里  pred_x = cal(pred_polys, y)
+        # pred_xs = pred_polys[:, 0] * ys**3 + pred_polys[:, 1] * ys**2 + pred_polys[:, 2] * ys + pred_polys[:, 3]
+        # pred_xs.t_()
+        # 贝塞尔曲线
+        pred_xs = cal_list(ys, target_xs, valid_xs, pred_polys)
+
         # 计算权重 有效 xs 求和得到一个标量 X
         # 有效 xs 按行求和得到一个 tensor
         # 使用 X 逐一除以 tensor 得到新的 tensor
diff --git a/train.py b/train.py
index bf907ed..90e39f0 100644
--- a/train.py
+++ b/train.py
@@ -151,7 +151,7 @@ def parse_args():
     # deterministic: 是否设置 cudnn.deterministic = True 和 cudnn.benchmark = False，以确保训练过程的确定性
     parser = argparse.ArgumentParser(description="Train PolyLaneNet")
     parser.add_argument("--exp_name", default="tusimple", help="Experiment name")
-    parser.add_argument("--cfg", default="./cfgs/tusimple.yaml", help="Config file")
+    parser.add_argument("--cfg", default="./cfgs/tusimple_bezier.yaml", help="Config file")
     parser.add_argument("--resume", action="store_true", help="Resume training")
     parser.add_argument("--validate", action="store_true", help="Validate model during training")
     parser.add_argument("--deterministic",
diff --git a/utils/evaluator.py b/utils/evaluator.py
index 0077f38..cd18ffc 100644
--- a/utils/evaluator.py
+++ b/utils/evaluator.py
@@ -13,7 +13,7 @@ class Evaluator(object):
         # self.predictions = np.zeros((len(dataset.annotations), dataset.max_lanes, 4 + poly_degree))
         self.predictions = None
         self.runtimes = np.zeros(len(dataset))
-        # 每个样本的损失的
+        # 每个样本的损失
         self.loss = np.zeros(len(dataset))
         # 保存实验结果的目录路径
         self.exp_dir = exp_dir
